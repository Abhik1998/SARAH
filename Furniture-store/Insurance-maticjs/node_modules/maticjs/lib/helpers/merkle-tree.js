"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _ethereumjsUtil = _interopRequireDefault(require("ethereumjs-util"));

var _safeBuffer = require("safe-buffer");

var sha3 = _ethereumjsUtil.default.sha3;

var MerkleTree =
/*#__PURE__*/
function () {
  function MerkleTree() {
    var leaves = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
    (0, _classCallCheck2.default)(this, MerkleTree);

    if (leaves.length < 1) {
      throw new Error('Atleast 1 leaf needed');
    }

    var depth = Math.ceil(Math.log(leaves.length) / Math.log(2));

    if (depth > 20) {
      throw new Error('Depth must be 20 or less');
    }

    var l = leaves.concat(Array.from(Array(Math.pow(2, depth) - leaves.length), function () {
      return _ethereumjsUtil.default.zeros(32);
    }));
    this.leaves = l;
    this.layers = [l];
    this.createHashes(this.leaves);
  }

  (0, _createClass2.default)(MerkleTree, [{
    key: "createHashes",
    value: function createHashes(nodes) {
      if (nodes.length === 1) {
        return false;
      }

      var treeLevel = [];

      for (var i = 0; i < nodes.length; i += 2) {
        var left = nodes[i];
        var right = nodes[i + 1];

        var data = _safeBuffer.Buffer.concat([left, right]);

        treeLevel.push(sha3(data));
      } // is odd number of nodes


      if (nodes.length % 2 === 1) {
        treeLevel.push(nodes[nodes.length - 1]);
      }

      this.layers.push(treeLevel);
      this.createHashes(treeLevel);
    }
  }, {
    key: "getLeaves",
    value: function getLeaves() {
      return this.leaves;
    }
  }, {
    key: "getLayers",
    value: function getLayers() {
      return this.layers;
    }
  }, {
    key: "getRoot",
    value: function getRoot() {
      return this.layers[this.layers.length - 1][0];
    }
  }, {
    key: "getProof",
    value: function getProof(leaf) {
      var index = -1;

      for (var i = 0; i < this.leaves.length; i++) {
        if (_safeBuffer.Buffer.compare(leaf, this.leaves[i]) === 0) {
          index = i;
        }
      }

      var proof = [];

      if (index <= this.getLeaves().length) {
        var siblingIndex;

        for (var _i = 0; _i < this.layers.length - 1; _i++) {
          if (index % 2 === 0) {
            siblingIndex = index + 1;
          } else {
            siblingIndex = index - 1;
          }

          index = parseInt(index / 2);
          proof.push(this.layers[_i][siblingIndex]);
        }
      }

      return proof;
    }
  }, {
    key: "verify",
    value: function verify(value, index, root, proof) {
      if (!Array.isArray(proof) || !value || !root) {
        return false;
      }

      var hash = value;

      for (var i = 0; i < proof.length; i++) {
        var node = proof[i];

        if (index % 2 === 0) {
          hash = sha3(_safeBuffer.Buffer.concat([hash, node]));
        } else {
          hash = sha3(_safeBuffer.Buffer.concat([node, hash]));
        }

        index = parseInt(index / 2);
      }

      return _safeBuffer.Buffer.compare(hash, root) === 0;
    }
  }]);
  return MerkleTree;
}();

exports.default = MerkleTree;