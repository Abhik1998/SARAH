"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getTxBytes = getTxBytes;
exports.getTxProof = getTxProof;
exports.getReceiptBytes = getReceiptBytes;
exports.getReceiptProof = getReceiptProof;
exports.verifyHeaderProof = verifyHeaderProof;
exports.verifyTxProof = verifyTxProof;
exports.verifyReceiptProof = verifyReceiptProof;
exports.squanchTx = squanchTx;

var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));

var _merklePatriciaTree = _interopRequireDefault(require("merkle-patricia-tree"));

var _ethereumjsUtil = _interopRequireDefault(require("ethereumjs-util"));

var _ethereumjsTx = _interopRequireDefault(require("ethereumjs-tx"));

var _fromRpc = _interopRequireDefault(require("ethereumjs-block/from-rpc"));

var _merkleTree = _interopRequireDefault(require("./merkle-tree"));

var rlp = _ethereumjsUtil.default.rlp;

function getTxBytes(tx) {
  var txObj = new _ethereumjsTx.default(squanchTx(tx));
  return txObj.serialize();
}

function getTxProof(_x, _x2) {
  return _getTxProof.apply(this, arguments);
}

function _getTxProof() {
  _getTxProof = (0, _asyncToGenerator2.default)(
  /*#__PURE__*/
  _regenerator.default.mark(function _callee(tx, block) {
    var txTrie, _loop, i;

    return _regenerator.default.wrap(function _callee$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            txTrie = new _merklePatriciaTree.default();
            _loop =
            /*#__PURE__*/
            _regenerator.default.mark(function _loop(i) {
              var siblingTx, path, rawSignedSiblingTx;
              return _regenerator.default.wrap(function _loop$(_context) {
                while (1) {
                  switch (_context.prev = _context.next) {
                    case 0:
                      siblingTx = block.transactions[i];
                      path = rlp.encode(siblingTx.transactionIndex);
                      rawSignedSiblingTx = getTxBytes(siblingTx);
                      _context.next = 5;
                      return new Promise(function (resolve, reject) {
                        txTrie.put(path, rawSignedSiblingTx, function (err) {
                          if (err) {
                            reject(err);
                          } else {
                            resolve();
                          }
                        });
                      });

                    case 5:
                    case "end":
                      return _context.stop();
                  }
                }
              }, _loop);
            });
            i = 0;

          case 3:
            if (!(i < block.transactions.length)) {
              _context2.next = 8;
              break;
            }

            return _context2.delegateYield(_loop(i), "t0", 5);

          case 5:
            i++;
            _context2.next = 3;
            break;

          case 8:
            return _context2.abrupt("return", new Promise(function (resolve, reject) {
              txTrie.findPath(rlp.encode(tx.transactionIndex), function (err, rawTxNode, reminder, stack) {
                if (err) {
                  return reject(err);
                }

                if (reminder.length > 0) {
                  return reject(new Error('Node does not contain the key'));
                }

                var prf = {
                  blockHash: _ethereumjsUtil.default.toBuffer(tx.blockHash),
                  parentNodes: stack.map(function (s) {
                    return s.raw;
                  }),
                  root: getRawHeader(block).transactionsTrie,
                  path: rlp.encode(tx.transactionIndex),
                  value: rlp.decode(rawTxNode.value)
                };
                resolve(prf);
              });
            }));

          case 9:
          case "end":
            return _context2.stop();
        }
      }
    }, _callee);
  }));
  return _getTxProof.apply(this, arguments);
}

function getReceiptBytes(receipt) {
  var status = receipt.root;

  if (receipt.status !== undefined && receipt.status !== null) {
    status = receipt.status;

    if (status === true) {
      status = '0x01';
    } else if (status === false) {
      status = '0x00';
    }
  } // raw receipt = rlp.encode([status or root, cumulativeGasUsed, logsBloom, logs])


  return rlp.encode([_ethereumjsUtil.default.toBuffer(status), _ethereumjsUtil.default.toBuffer(receipt.cumulativeGasUsed), _ethereumjsUtil.default.toBuffer(receipt.logsBloom), // encoded log array
  receipt.logs.map(function (l) {
    // [address, [topics array], data]
    return [_ethereumjsUtil.default.toBuffer(l.address), // convert address to buffer
    l.topics.map(_ethereumjsUtil.default.toBuffer), // convert topics to buffer
    _ethereumjsUtil.default.toBuffer(l.data)];
  })]);
}

function getReceiptProof(_x3, _x4, _x5) {
  return _getReceiptProof.apply(this, arguments);
}

function _getReceiptProof() {
  _getReceiptProof = (0, _asyncToGenerator2.default)(
  /*#__PURE__*/
  _regenerator.default.mark(function _callee2(receipt, block, web3) {
    var receiptsTrie, receiptPromises, receipts, _loop2, i;

    return _regenerator.default.wrap(function _callee2$(_context4) {
      while (1) {
        switch (_context4.prev = _context4.next) {
          case 0:
            receiptsTrie = new _merklePatriciaTree.default();
            receiptPromises = [];
            block.transactions.forEach(function (tx) {
              receiptPromises.push(web3.eth.getTransactionReceipt(tx.hash));
            });
            _context4.next = 5;
            return Promise.all(receiptPromises);

          case 5:
            receipts = _context4.sent;
            _loop2 =
            /*#__PURE__*/
            _regenerator.default.mark(function _loop2(i) {
              var siblingReceipt, path, rawReceipt;
              return _regenerator.default.wrap(function _loop2$(_context3) {
                while (1) {
                  switch (_context3.prev = _context3.next) {
                    case 0:
                      siblingReceipt = receipts[i];
                      path = rlp.encode(siblingReceipt.transactionIndex);
                      rawReceipt = getReceiptBytes(siblingReceipt);
                      _context3.next = 5;
                      return new Promise(function (resolve, reject) {
                        receiptsTrie.put(path, rawReceipt, function (err) {
                          if (err) {
                            reject(err);
                          } else {
                            resolve();
                          }
                        });
                      });

                    case 5:
                    case "end":
                      return _context3.stop();
                  }
                }
              }, _loop2);
            });
            i = 0;

          case 8:
            if (!(i < receipts.length)) {
              _context4.next = 13;
              break;
            }

            return _context4.delegateYield(_loop2(i), "t0", 10);

          case 10:
            i++;
            _context4.next = 8;
            break;

          case 13:
            return _context4.abrupt("return", new Promise(function (resolve, reject) {
              receiptsTrie.findPath(rlp.encode(receipt.transactionIndex), function (err, rawReceiptNode, reminder, stack) {
                if (err) {
                  return reject(err);
                }

                if (reminder.length > 0) {
                  return reject(new Error('Node does not contain the key'));
                }

                var prf = {
                  blockHash: _ethereumjsUtil.default.toBuffer(receipt.blockHash),
                  parentNodes: stack.map(function (s) {
                    return s.raw;
                  }),
                  root: getRawHeader(block).receiptTrie,
                  path: rlp.encode(receipt.transactionIndex),
                  value: rlp.decode(rawReceiptNode.value)
                };
                resolve(prf);
              });
            }));

          case 14:
          case "end":
            return _context4.stop();
        }
      }
    }, _callee2);
  }));
  return _getReceiptProof.apply(this, arguments);
}

function verifyHeaderProof(_ref) {
  var value = _ref.value,
      valueIndex = _ref.valueIndex,
      headerRoot = _ref.headerRoot,
      proof = _ref.proof;

  var bufferedValue = _ethereumjsUtil.default.toBuffer(value);

  var tree = new _merkleTree.default([bufferedValue]);
  return tree.verify(bufferedValue, valueIndex, _ethereumjsUtil.default.toBuffer(headerRoot), proof.map(function (p) {
    return _ethereumjsUtil.default.toBuffer(p);
  }));
}

function verifyTxProof(proof) {
  var path = _ethereumjsUtil.default.toBuffer(proof.path).toString('hex');

  var value = rlp.decode(_ethereumjsUtil.default.toBuffer(proof.value));
  var parentNodes = rlp.decode(_ethereumjsUtil.default.toBuffer(proof.parentNodes));

  var txRoot = _ethereumjsUtil.default.toBuffer(proof.root);

  try {
    var currentNode;
    var len = parentNodes.length;
    var nodeKey = txRoot;
    var pathPtr = 0;

    for (var i = 0; i < len; i++) {
      currentNode = parentNodes[i];
      var encodedNode = Buffer.from(_ethereumjsUtil.default.sha3(rlp.encode(currentNode)), 'hex');

      if (!nodeKey.equals(encodedNode)) {
        return false;
      }

      if (pathPtr > path.length) {
        return false;
      }

      switch (currentNode.length) {
        case 17:
          // branch node
          if (pathPtr === path.length) {
            if (currentNode[16] === rlp.encode(value)) {
              return true;
            } else {
              return false;
            }
          }

          nodeKey = currentNode[parseInt(path[pathPtr], 16)]; // must === sha3(rlp.encode(currentNode[path[pathptr]]))

          pathPtr += 1;
          break;

        case 2:
          pathPtr += nibblesToTraverse(currentNode[0].toString('hex'), path, pathPtr);

          if (pathPtr === path.length) {
            // leaf node
            if (currentNode[1].equals(rlp.encode(value))) {
              return true;
            } else {
              return false;
            }
          } else {
            // extension node
            nodeKey = currentNode[1];
          }

          break;

        default:
          return false;
      }
    }
  } catch (e) {
    return false;
  }

  return false;
}

function verifyReceiptProof(proof) {
  return verifyTxProof(proof, true);
} //
// Helper methods
//
// raw header


function getRawHeader(_block) {
  if (typeof _block.difficulty !== 'string') {
    _block.difficulty = '0x' + _block.difficulty.toString(16);
  }

  var block = new _fromRpc.default(_block);
  return block.header;
} // squanch transaction


function squanchTx(tx) {
  tx.gasPrice = '0x' + parseInt(tx.gasPrice).toString(16);
  tx.value = '0x' + parseInt(tx.value).toString(16) || '0';
  tx.gas = '0x' + parseInt(tx.gas).toString(16);
  tx.data = tx.input;
  return tx;
}

function nibblesToTraverse(encodedPartialPath, path, pathPtr) {
  var partialPath;

  if (String(encodedPartialPath[0]) === '0' || String(encodedPartialPath[0]) === '2') {
    partialPath = encodedPartialPath.slice(2);
  } else {
    partialPath = encodedPartialPath.slice(1);
  }

  if (partialPath === path.slice(pathPtr, pathPtr + partialPath.length)) {
    return partialPath.length;
  } else {
    throw new Error('path was wrong');
  }
}